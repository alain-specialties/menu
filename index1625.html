<!DOCTYPE html>
<html lang="nl">
<head>
<meta charset="UTF-8">
<title>Data Viewer</title>
<style>
    body {
        font-family: Arial, sans-serif;
        background-color: #111;
        color: white;
        padding: 20px;
        user-select: none;
    }
    h1 { text-align: center; color: #c0a16b; }
    #loginBox { text-align: center; margin-top: 100px; }
    input { padding: 8px; margin: 5px; }
    table { width: 100%; border-collapse: collapse; margin-top: 15px; cursor: default; }
    th, td { border: 1px solid #555; padding: 6px; text-align: center; }
    th { background-color: #333; cursor: pointer; }
    tr:nth-child(even) { background-color: #222; }
    #searchBox { margin: 10px 0; padding: 8px; width: 300px; }
    th.sort-asc::after { content: " \25B2"; }
    th.sort-desc::after { content: " \25BC"; }
</style>
</head>
<body oncontextmenu="return false;">
<h1>Data Viewer</h1>
<div id="loginBox">
    <h2>Login</h2>
    <input type="text" id="username" placeholder="Gebruikersnaam"><br>
    <input type="password" id="password" placeholder="Wachtwoord"><br>
    <button onclick="checkLogin()">Inloggen</button>
    <p id="loginError" style="color:red;"></p>
</div>
<div id="catalog" style="display:none;">
    <input type="text" id="searchBox" placeholder="Zoeken..." onkeyup="filterTable()">
    <table id="cigarTable">
        <thead>
            <tr id="headerRow"></tr>
        </thead>
        <tbody></tbody>
    </table>
</div>
<script>
// ===== Helpers =====
function stripBOM(s){ return s && s.charCodeAt(0)===0xFEFF ? s.slice(1) : s; }

function detectDelimiter(text){
    const firstLine = (text.split(/\r?\n/).find(l=>l.trim().length>0) || "");
    const counts = { ';':0, ',':0, '\t':0, '|':0 };
    let inQuotes = false;
    for (let i=0;i<firstLine.length;i++){
        const ch = firstLine[i];
        if (ch === '"'){
            if (inQuotes && firstLine[i+1] === '"'){ i++; continue; }
            inQuotes = !inQuotes; continue;
        }
        if (!inQuotes && counts.hasOwnProperty(ch)) counts[ch]++;
    }
    let best = ';', bestCount = -1;
    for (const k in counts){ if (counts[k] > bestCount){ best = k; bestCount = counts[k]; } }
    return bestCount <= 0 ? ';' : best;
}

function parseCSV(text, delimiter){
    const rows = [];
    let row = [], field = '';
    let inQuotes = false;
    for (let i=0;i<text.length;i++){
        const ch = text[i];
        if (ch === '"'){
            if (inQuotes && text[i+1] === '"'){ field += '"'; i++; continue; }
            inQuotes = !inQuotes; continue;
        }
        if (!inQuotes && ch === delimiter){ row.push(field); field=''; continue; }
        if (!inQuotes && (ch === '\n' || ch === '\r' && text[i+1] !== '\n')){
            row.push(field); rows.push(row); row=[]; field=''; continue;
        }
        if (!inQuotes && ch === '\r'){ continue; }
        field += ch;
    }
    if (field.length || row.length){ row.push(field); rows.push(row); }
    return rows.filter(r => r.some(cell => String(cell).trim() !== ''));
}

function normalizeKey(s){
    return String(s||'')
        .toLowerCase()
        .normalize('NFD').replace(/[̀-ͯ]/g,'')
        .replace(/€/g,'eur')
        .replace(/[^a-z0-9#]+/g,'');
}

const TARGETS = [
  { label: 'Stock',  keys: ['stock','voorraad'], loose:['qty','quantity'] },
  { label: 'Brand',  keys: ['brand'] },
  { label: 'Brand 2',keys: ['brand2','brand_2','subbrand','lijn','line'] },
  { label: 'Brand 3',keys: ['brand3','brand_3','series','serie','subline'] },
  { label: '€ Unit', keys: ['eurunit','unitprice','priceunit','prijsperstuk','prijsunit','uniteur','priceeur','eurpcs','eurperunit'], loose:['perunit','unit'] },
  { label: '# Box',  keys: ['#box','qtybox','aantalperbox','aantalbox','unitsperbox','pcsperbox','perbox','nbox'] },
  { label: '€ Box',  keys: ['eurbox','boxprice','prijsbox','prijsperbox','boxeur','eurperbox'] },
  { label: 'Size',   keys: ['size','maat','afmeting','lengthring','format','vitola'] },
  { label: 'Country',keys: ['country','land','origin','herkomst','origine'] }
];

function buildHeaderMapping(header){
    const norm = header.map(normalizeKey);
    const used = new Set();
    const mapping = new Array(TARGETS.length).fill(-1);

    function findIndex(keys, allowLoose){
        for (let i=0;i<norm.length;i++){
            if (used.has(i)) continue;
            for (const k of keys){ if (norm[i] === k) { used.add(i); return i; } }
        }
        if (!allowLoose) return -1;
        for (let i=0;i<norm.length;i++){
            if (used.has(i)) continue;
            for (const k of keys){ if (norm[i].includes(k)) { used.add(i); return i; } }
        }
        return -1;
    }

    TARGETS.forEach((t, idx) => {
        let i = findIndex(t.keys, false);
        if (i === -1 && t.loose) i = findIndex(t.loose, true);
        mapping[idx] = i;
    });

    return { mapping, norm };
}

// ===== Login check =====
function checkLogin() {
    const user = document.getElementById("username").value.trim();
    const pass = document.getElementById("password").value.trim();
    if (user === "Philbo" && pass === "sigaren2025") {
        document.getElementById("loginBox").style.display = "none";
        document.getElementById("catalog").style.display = "block";
        loadCSV();
    } else {
        document.getElementById("loginError").innerText = "Ongeldige login!";
    }
}

// ===== CSV laden en in tabel zetten =====
function loadCSV() {
    fetch("data.csv", { cache: 'no-cache' })
        .then(response => { if (!response.ok) throw new Error('data.csv niet gevonden'); return response.text(); })
        .then(text => {
            text = stripBOM(text);
            const delim = detectDelimiter(text);
            const rows = parseCSV(text, delim);
            if (!rows.length) throw new Error('CSV is leeg');

            const header = rows[0];
            const { mapping } = buildHeaderMapping(header);
            const mappedCount = mapping.filter(i=>i>=0).length;
            const haveHeader = mappedCount >= 4;
            const dataRows = haveHeader ? rows.slice(1) : rows;

            const effectiveMapping = mapping.map((i, idx) => (haveHeader && i>=0) ? i : idx);

            const headerRow = document.getElementById("headerRow");
            headerRow.innerHTML = '';
            TARGETS.forEach((t, idx) => {
                if (effectiveMapping[idx] < rows[0].length) {
                    const th = document.createElement("th");
                    th.textContent = t.label;
                    th.addEventListener("click", () => sortTable(idx));
                    headerRow.appendChild(th);
                }
            });

            const tbody = document.querySelector("#cigarTable tbody");
            tbody.innerHTML = '';
            dataRows.forEach(r => {
                const tr = document.createElement("tr");
                effectiveMapping.forEach((srcIdx, c) => {
                    if (srcIdx < r.length) {
                        const td = document.createElement("td");
                        td.textContent = r[srcIdx];
                        tr.appendChild(td);
                    }
                });
                tbody.appendChild(tr);
            });
        })
        .catch(err => {
            alert('Fout bij laden: ' + err.message);
        });
}

// ===== Zoekfunctie =====
function filterTable() {
    const search = document.getElementById("searchBox").value.toLowerCase();
    const rows = document.querySelectorAll("#cigarTable tbody tr");
    rows.forEach(row => {
        row.style.display = row.innerText.toLowerCase().includes(search) ? "" : "none";
    });
}

// ===== Sorteren =====
let currentSort = { index: -1, asc: true };
function sortTable(colIndex) {
    const tbody = document.querySelector("#cigarTable tbody");
    const rows = Array.from(tbody.querySelectorAll("tr"));
    const headers = document.querySelectorAll("#headerRow th");

    headers.forEach(h => h.classList.remove("sort-asc","sort-desc"));

    let asc = true;
    if (currentSort.index === colIndex) asc = !currentSort.asc;
    currentSort = { index: colIndex, asc };

    rows.sort((a, b) => {
        const A = a.children[colIndex]?.innerText.trim() || "";
        const B = b.children[colIndex]?.innerText.trim() || "";
        const numA = parseFloat(A.replace(/[^0-9.,-]/g,""));
        const numB = parseFloat(B.replace(/[^0-9.,-]/g,""));
        if (!isNaN(numA) && !isNaN(numB)) {
            return asc ? numA - numB : numB - numA;
        }
        return asc ? A.localeCompare(B) : B.localeCompare(A);
    });

    rows.forEach(r => tbody.appendChild(r));

    headers[colIndex].classList.add(asc ? "sort-asc" : "sort-desc");
}

// ===== Beperk kopiëren/printen =====
document.addEventListener("keyup", function(e) {
    if (e.key === "PrintScreen") {
        alert("Print Screen is gedeactiveerd!");
        if (navigator.clipboard && navigator.clipboard.writeText) {
            navigator.clipboard.writeText("");
        }
    }
});

document.addEventListener("keydown", function(e) {
    const k = e.key.toLowerCase();
    if ((e.ctrlKey && (k === "c" || k === "p" || k === "s")) || (e.metaKey && (k === "c" || k === "p" || k === "s"))) {
        e.preventDefault();
        alert("Kopiëren/printen/opslaan is geblokkeerd!");
    }
});
</script>

</body>
</html>

